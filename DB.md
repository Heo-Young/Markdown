# Data Modeling, Database Design Fundamentals

## 목표
- 데이터베이스 구성 기본 개념에 대해 이해

## RDBMS
- 데이터베이스 시스템(DBS: DataBase System)
    - 데이터베이스에 데이터를 저장하고, 이를 관리하여 조직에 필요한 정보를 생성 해주는 시스템
    - 구성요소
        - 사용자
        - 데이터언어
        - 데이터베이스 관리 시스템
        - 데이터 베이스
        ![9](/img/9.PNG)
- 스키마와 인스턴스
    - 스키마
        - DB에 저장되는 데이터 구조와 제약조건을 정의한 것
        - 고객 - 고객번호 정수, 이름 문자열(10), 나이 정수, 주소 문자열(20)
    - 인스턴스
        - 스키마에 따라 DB에 실제로 저장된 값
        - 고객1 - 123, kim, 25, 전남 무안군 청계면

- 데이터 언어
    - 데이터 정의어 : 스키마 정의, 수정, 삭제
        - DDL(Data Definition Language) : CREATE, ALTER, DROP
    - 데이터 조작어 : 데이터의 삽입, 삭제, 수정, 검색 요구
        - DML(Data Manipulation Language) : INSERT, DELETE, UPDATE, SELECT
            - 절차적 데이터 조작어
            - 비절차적 데이터 조작어
                - 선언적 언어
    - 데이터 제어어 : 내부적으로 필요한 규칙, 기법 정의
        - DCL(Data Control Language) : GRANT, REVOKE
- 데이터 베이스 관리 시스템
    - 질의 처리기
        - 사용자의 데이터 처리 요구를 해석하여 처리
        - 종류
            - DDL 컴파일러 : DDL로 작성된 스키마의 정의를 해석
            - DML 프리 컴파일러 : 응용 프로그램에 삽입된 DML를 추출하여 DML 컴파일러에 전달
            - DML 컴파일러 : DML로 작성된 데이터의 처리 요구를 분석하여 런타임 데이터베이스 처리기가 이해할 수 있도록 해석
            - 런타임 데이터베이스 처리기 : 저장 데이터 관리자를 통해 데이터 베이스에 접근, DML 컴파일러로 부터 받은 데이터 처리요구를 데이터베이스에서 실제로 실행
            - 트랜잭션 관리자 : 데이터베이스에 접근하는 과정에서 사용자의 접근 권한의 유효성 검사, 제약조건 위반 여부를 확인, 회복, 병행과 관련한 작업 수행
    - 저장 데이터 관리자
        - 디스크에 저장된 사용자 데이터베이스와 데이터 사전을 관리하고, 데이터베이스에 실제로 접근하는 역할 담당
    - 데이터베이스 관리 시스템의 구성
    ![10](/img/10.PNG)

- 데이터 모델링
    - D = <S,O,C>
        - D(Data):데이터 모델 = <S(Structure): 구조, O(Operation): 연산, C(Constraint): 제약조건>
    - 개념적 -> 논리적 -> 물리적

    - 개념적 모델링
        - E-R 다이어그램 : 개념적 모델링을 그림으로 표현한것
        - 개체(entity) : 저장할 가치가 있는 중요 데이터를 가지고 있는 사람,사물, 개념, 사건 등 각 개체만의 고유한 특성이나 상태, 즉 속성을 하나 이상 가지고 있다(E-R 다이어그램에서 사각형으로 표현하고 사각형 안에 이름 표기)
            - 개체 타입 : 개체를 고유의 이름과 속성들로 정의한 것
            - 개체 인스턴스 : 개체를 구성하공 있는 속성의 실제 값
            - 개체 집합 : 특정 개체 타입에 대한 개체 인스턴스들을 모아둔 것
        - 속성(attribute) : 개체나 관계가 가지고 있는 고유의 특성, 의미 있는 데이터의 가장 작은 논리적 단위(E-R 다이어그램에서 타원으로 표현하고 타원 안에 이름 표기)
            - 속성의 분류
                - 속성값의 개수에 따라
                    - 단일 값 속성 : 값을 하나만 가질 수 있는 속성
                    - 다중 값 속성 : 값을 여러 개 가질 수 있는 속성(E-R 다이러그램에서 이중 타원으로 표형)
                - 의미의 분해 가능성에 따라
                    - 단순 속성 : 의미를 더를 분해할 수 없는 속성
                    - 복합 속성 : 의미를 분해할 수 있는 속성
                - 다른 속성에 의해 값이 유도되어 결정되는 경우
                    - 유도 속성 : 기존의 다른 속성의 값에서 유도되어 결정되는 속성 값이 별도로 저장되지 않음(E-R 다이어그램에서 점선 타원으로 표현)
                - 널 속성 : 널 값이 허용되는 속성
                - 키 속성 : 각 개체 인스턴스를 식별하는 데 사용되는 속성 모든 개체 인스턴스의 키 속성 값이 다름 둘 이상의 속성들로 구성되기도 함(E-R 다이어그램에서 밑줄로 표현)
        - 관계(relationship) : 개체와 개체가 맺고 있는 의미 있는 연관성 개체 집합들 사이의 대응관계, 즉 매핑(mapping)을 의미(E-R 다이어그램에서 마름모로 표현)
            - 관계의 유형
                - 관계에 참여하는 개체 타입의 수 기준
                    - 이항 관계 : 개체 타입 두 개가 맺는 관계
                    - 삼항 관계 : 개체 타입 세 개가 맺는 관계
                    - 순환 관계 : 개체 타입 하나가 자기 자신과 맺는 관계
                - 매핑 카디널리티 기준(개체-관계 다이어그램에서 레이블로 표기)
                    - 일대일(1:1)관계
                    - 일대다(1:n)관계
                    - 다대다(n:m)관계
                - 매핑 카디널리티 : 관계를 맺는 두 개체 집합에서, 각 개체 인스턴스가 연관성을 맺고 있는 상대 개체 집합의 인스턴스 개수
            - 관계의 참여 특성
                - 필수적 참여(전체 참여)
                    - 모든 개체 인스턴스가 관계에 반다시 참여해야 하는 것을 의미
                    - E-R 다이어그램에서 이중선으로 표현
                - 선택적 참여(부분 참여)
                    - 개체 인스턴스 중 일부만 관계에 참여해도 되는 것을 의미
    - 논리적 모델링
        - 관계 데이터 모델 : 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델, 하나의 개체에 대한 데이터를 하나의 릴레이션에 저장
            - 릴레이션(relation) : 하나의 개체에 관한 데이터를 구조로 저장한 것, 파일 관리 시스템 관점에서 파일(file)
                - 릴레이션 스키마 : 릴레이션의 논리적 구조, 릴레이션의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의( 예: 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금) )
                - 릴레이션 인스턴스 : 어느 한 시점에 릴레이션에 존재하는 투플들의 집합
            - 투플(tuple) : 릴레이션의 행, 파일 관리 시스템 관점에서 레코드(record)
            - 속성(attribute) : 릴레이션의 열, 파일 관리 시스템 관점에서 필드(field)
                - 릴레이션 예
                ![11](/img/11.PNG)
            - 차수(degree) : 하나의 릴레이션에서 속성의 전체 개수, 최소 차수는 1
            - 카디널리티(cardicality) : 하나의 릴레이션에서 투플의 전체 개수, 유효한 카디널리티는 0부터 시작
            - 널(null): 속성 값을 아직 모르거나 해당되는 값이 없음을 표현
            - 도메인(domain) : 하나의 속성이 가질 수 있는 모든 값의 집합, 데이터 타입
        - 데이터베이스의 구성
            - 데이터베이스 스키마 : DB의 전체 구조, DB를 구성하는 릴레이션 스키마의 모음
            - 데이터베이스 인스턴스 : DB를 구성하는 릴레이션 인스턴스의 모음
            ![12](/img/12.PNG)
        - 릴레이션 키
            - 릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합
            - 특성
                - 유일성 : 한 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함
                - 최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성
            - 종류
                - 슈퍼키(super key) : 유일성을 만족하는 속성 또는 속성들의 집합
                - 후보키(candidate key) : 유일성과 최고성을 만족하는 속성 또는 속성들의 집합
                - 기본키(primary key) : 후보키 중에서 기본적으로 사용하기 위해 선택한 키
                - 대체키(alternate key) : 기본키로 선택되지 못한 후보키
                - 키들의 포함 관계
                ![13](/img/13.PNG)
                - 외래키(foreign key) : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합, 릴레리션들 간의 관계를 표현한다.
                    - 참조하는 릴레이션 : 외래키를 가진 릴레이션
                    - 참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션
        - 관계 데이터 모델의 제약
            - 무결성 제약조건(Integrity Constraint)
                - 일관된 데이터베이스 상태를 정의하는 규칙들을 묵시적으로 또는 명시적으로 정의함
                - 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것
                - 종류
                    - 개체 무결성 제약조건(Entity Integrity Constraint) : 기본키를 구성하는 모든 속성은 널 값을 가질 수 없음
                    - 참조 무결성 제약조건(Referential Intergrity Constraint) : 외래키는 참조할 수 없는 값을 가질 수 없음
- 관계 데이터 연산
    - 관계 데이터 모델의 연산
    - 원하는 데이터를 얻기 위해 릴레이션에 필요한 처리 요구를 수행하는 것
    - 관계 대수와 관계 해석이 있음, 이 둘은 데이터 언어의 유용성을 검증하는 기준
        - 관계 대수 : 원하는 결과를 얻기 위해 데이터 처리 과정을 순서대로 기술하는 절차적 언어
        - 관계 해석 : 원하는 결과를 얻기 위해 처리를 원하는 데이터가 무엇인지만 기술하는 비절차적 언어(SQL)
- SQL
    - SQL분류
        - 데이터 정의어(DDL) : CREATE(CREATE TABLE), ALTER(ALTER TABLE), DROP(DROP TABLE)
            - CREATE 기본 형식
            ```SQL
            --------------------------------------기본 테이블 생성
            CREATE TABLE 테이블이름(
                {속성 이름 데이터 타입 [NOT NULL] [DEFAULT 값],}
                [PRIMARY KEY (속성이름_리스트),] -- 기본키
                {[UNIQUE (속성이름_리스트),]} -- 대체키
                {[FOREINGN KEY(속성이름_리스트)
                REFERENCES 기본테이블[(속성이름_리스트)]
                [ON DELETE 옵션] -- ON DELETE NO ACTION: 투플을 삭제하지 못하게 함
                                -- ON DELETE CASCADE: 관련 투플을 함께 삭제함
                                -- ON DELETE SET NULL: 관련 투플의 외래키 값을 NULL로 변경함
                                -- ON DELETE SET DEFAULT: 관련 투플의 외래키 값을 미리 지정한 기본값 으로 변경함
                [ON UPDATE 옵션] -- ON UPDATE NO ACTION: 투플을 변경하지 못하게 함
                                -- ON UPDATE CASCADE: 관련 투플의 외래키 값을 함께 변경함
                                -- ON UPDATE SET NULL: 관련 투플의 외래키 값을 NULL로 변경함
                                -- ON UPDATE SET DEFAULT: 관련 투플의 외래키 값을 미리 지정한 기본값으로 변경함
                , ]} -- 외래키
                [CONSTRAINT 이름] [CHECK(조건식)] -- 제약조건
            );
            --------------------------------------SELECT문을 이용한 테이블 생성
            CREATE TABLE 테이블_이름
            AS
            SELECT 문;
            ```
            - ALTER TABLE 기본 형식
            ```SQL
            ALTER TABLE 테이블_이름
                ADD 속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본값]; -- 새로운 속성 추가
            
            ALTER TABLE 테이블_이름
                DROP COLUMN 속성_이름; -- 기존 속성 삭제

            ALTER TABLE 테이블_이름
                MODIFY 속성_이름 데이터_타입; -- 기존 속성 변경

            ALTER TABLE 테이블_이름
                ADD CONSTRAINT 제약조건_이름 CHECK(제약조건_내용); -- 새로운 제약조건 추가

            ALTER TABLE 테이블_이름
                DROP CONSTRAINT 제약조건_이름; -- 기존 제약조건 제거

            ALTER TABLE 테이블_이름
                MODIFY 속성_이름 데이터_타입 [NULL | NOT NULL]; -- NOT NULL 또는 NULL 속성 변경
            
            ALTER TABLE 테이블_이름
                RENAME COLUMN 기존_속성_이름 TO 새로운_속성_이름; -- 속성이름 변경
            ```
            - DROP TABLE 기본 형식
            ```SQL
            DROP TABLE 테이블_이름;
            ```
            - 논외
            ```SQL
            RENAME 기존_테이블_이름 TO 새로운_테이블_이름; -- 테이블명 변경
            ```
        - 데이터 조작어(DML) : SELECT, INSERT, UPDATE, DELETE
            - SELECT 기본 형식
            ```SQL
            SELECT [ALL | DISTINCT] 속성_리스트 -- ALL(중복허용), DISTINC(중복불허용)
                                            -- 집계함수
                                            -- SUM(속성_이름) : 합계 AVG(속성_이름) : 평균, COUNT(속성_이름) : 개수
                                            -- MAX(속성_이름) : 최대값, MIN(속성_이름) : 최소값
            FROM 테이블_리스트
            [WHERE 조건] -- 비교 연산자와 논리 연산자를 이용한 검색 조건 제시
                        -- 비교연산자 : =, <>, <=, >=, <, >
                        -- 논리연산자 : AND, OR, NOT
                        -- 범위 : BETWEEN A AND B
                        -- 집합 : IN, NOT IN
                        -- 패턴 : LIKE
                        -- NULL : IS NULL, IN NOT NULL
            [GROUP BY 속성_리스트 [HAVING 조건]] -- 그룹별 검색 HAVIGN 키워드를 콩해 그룹에 대한 조건을 작성
            [ORDER BY 속성_리스트 [ASC | DESC]] -- ASC(오름차순), DESC(내림차순)
            ;
            ```
            - JOIN을 이용한 SELECT문
            ```SQL
            --------------------------------내부 조인
            SELECT 속성_리스트
            FROM A INNER JOIN B
            ON A.속성_이름 = B.속성_이름
            --------------------------------외부 조인
            SELECT 속성_리스트
            FROM A [LEFT|RIGHT|FULL]OUTER JOIN B
            ON A.속성_이름 = B.속성_이름
            --------------------------------셀프 조인
            SELECT 속성_리스트
            FROM 테이블.A-1 JOIN 테이블.A-2
            WHERE A-1.속성_이름 = A-2.속성_이름
            ```
            - INSERT 기본 형식
            ```SQL
            --------------------------------------기본 데이터 삽입
            INSERT
            INTO 테이블_이름[(속성_리스트)]
            VALUES (속성값_리스트);
            --------------------------------------SELECT문을 이용해 데이터 삽입
            INSERT
            INTO 테이블_이름[(속성_리스트)]
            SELECT 문;
            ```
            - UPDATE 기본 형식
            ```SQL
            UPDATE 테이블_이름
            SET 속성_이름1 = 값1, 속성_이름2 = 값2, ...
            [WHERE 조건];
            ```
            - DELETE 기본 형신
            ```SQL
            DELETE
            FROM 테이블_이름
            [WHERE 조건];
            ```
        - 데이터 제어어(DCL) : GRANT, REVOKE
            - 기본 형식
            ```SQL
            --------------------------------------GRANT
            GRANT 권한 ON 객체 TO 사용자 [WITH GRANT OPTION];
            --------------------------------------REVOKE
            REVOKE 권한 ON 객체 FROM 사용자 CASADE CONSTRAINTS | RESTRICT;
            ```

- 데이터베이스 설계
    - E-R모델과 릴레이션 변환 규칙을 이용한 설계의 과정
        - ![14](/img/14.PNG)
    - 개념적 설계
        - 작업 과정
            - 1.개체 추출, 각 개체의 주요 속성과 키 속성 선별
                - 개체 : 저장할만한 가치가 있는 중요 데이터를 가진 사람이나 사물 등
                - 요구 사항 문장에서 업무와 관련이 깊은 의미 있는 명사를 찾아라!
                - 업무와 관련이 적은 일반적이고 광범위한 의미의 명사는 제외
                - 의미가 같은 명사가 여러 개일 경우는 대표 명사 하나만 선택
                - 찾아낸 명사를 개체와 속성으로 분류
            - 2.개체 간의 관계 결정
                - 관계 : 개체 간의 의미 있는 연관성
                - 요구 사항 문장에서 개체 간의 연관성을 의미 있게 표현한 동사를 찾기
                - 의미가 같은 동사가 여러 개일 경우는 대표 명사 하나만 선택
                - 찾아낸 관계에 대해 매핑 카니널리티와 참여 특성을 결정
                    - 매핑 카니널리티 : 일대일(1:1), 일대다(1:n), 다대다(n:m)
                    - 참여 특성 : 필수적 참여/선택적 참여
            - 3.E-R다이어그램으로 표현
    - 논리적 설계
        - E-R다이어그램을 릴레이션 스키마로 변환하는 규칙
            - 1: 모든 개체는 릴레이션으로 변환한다.
            - 2: 다대다(n:m) 관계는 릴레이션으로 변환한다.
                - 릴레이션의 기본키를 관계 릴레이션에 포함시켜 외래키로 지정
                - 외래키들을 조합하여 관계 릴레이션의 기본키로 지정 또는, 새로운 속성을 하나 추가하여 기본키로 지정
            - 3: 일대다(1:n) 관계는 외래키로 표현한다.
                - 1측 개체 릴레이션의 기본키를 n측 개체 릴레이션에 포함시켜 외래키로 지정
                - 관계의 속성들도 n측 개체 릴레이션에 포함시킴
            - 4: 일대일(1:1) 관계는 외래키로 표현한다.
                - 일반적인 일대일 관계는 외래키를 서로 주고 받는다.
                - 일대일 관계에 필수적으로 참여하는 개체의 릴레이션만 외래키를 받는다.
                - 모든 개체가 일대일 관계에 필수적으로 참여하면 릴레이션을 하나로 합친다.
            - 5: 다중 값 속성은 릴레이션으로 변환한다.
                - E-R다이어그램의 다중값 속성은 독립적인 릴레이션으로 변환
                -다중값 속성과 함께 그 속성을 가지고 잇던 개체 릴레이션의 기본키를 외래키로 가져와 새로운 릴레이션에 포함시킴
                - 새로운 릴레이션의 기본키는 다중값 속성과 외래키를 조합하여 지정
            - 6: 모든 관계를 독립적인 릴레이션으로 변환할 수 있다.
    - 물리적 설계
        - 하드웨어나 운영체제의 특성을 고려하여 필요한 인덱스 구조나 내부 저장 구조 등에 대한 물리적 구조를 설계(물리적 스키마, 테이블 명세서)
    - 구현
        - DBMS에 SQL언어를 사용하여 실제 데이터베이스를 생성
- 정규화
    - 삽입 이상 : 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
    - 갱신 이상 : 중복 투플 중 일부만 변경하여 데이터가 불일치하게 되는 문제
    - 삭제 이상 : 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제
    - 정규화 : 이상 현상이 발생하지 않도록, 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해 하는 과정, 함수적 종속성을 판단하여 정규화 수행
        - 함수적 종속성 : 속성들 간의 관련성
        - 완전 함수 종속(FFD: Full Functional Dependency) : 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X의 전체가 아닌 일부분에는 종속되지 않음을 의미 예) 당첨여부_Y는 {고객아이디_X-1, 이벤트번호_X-2}에 완전 함수 종속됨
        - 부분 함수 종속(PFD: Partial Functional Dependency) : 릴레이션에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미 예) 고객이름_Y은 {고객아이디_X-1, 이벤트번호_X-2}에 부분 함수 종속됨
        - 정규화를 통해 릴레이션은 무손실 분해 되어야 한다.
    - 정규형
        - ![15](/img/15.PNG)
        - 제 1정규형
            - 릴레이션의 모든 속성이 더는 분해되지 않는 원자값만 가진다
        - 제 2정규형
            - 릴레이션이 제 1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전함수 종속되면 제 2정규형을 만족함
        - 제 3정규형
            - 릴레이션이 제 2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않으면 제 3정규형을 만족함
                - 이행적 함수 종속 : 릴레이션을 구성하는 세 개의 속성 집합 X, Y, Z에 대해 함수 종속 관계 X > Y, Y > Z가 존재하면 논리적으로 X > Z가 성립되는데, 이것을 Z가 X에 이행적으로 함수 종속되었다고 함
        - 보이스/코드 정규형 BCNF형
            - 후보키를 여러 개 가지고 있는 릴레이션에 발생할 수 있는 이상 현상을 해결하기 위해 제 3정규형 보다 좀 더 엄격한 제약조건을 제시
            - 보이스/코드 정규형에 속하는 모든 릴레이션은 제 3정규형에 속하지만, 제 3정규형에 속하는 모든 릴레이션이 보이스/코드 정규형에 속하는 것은 아님
        - 제 4정규형
            - 릴레이션이 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치종속을 제거하면 제 4정규형에 속함
        - 제 5정규형
            - 릴레이션이 제 4정규형을 만족하면서, 후보키를 통하지 않는 조인 종속을 제거하면 제 5정규형에 속함
    - 정규화 과정
        - ![16](/img/16.PNG)
- 뷰
    - 테이블을 기반으로 만들어진 가산 테이블
    - 데이터를 실제로 저장하지 않고 논리적으로만 존재하는 테이블
    - 뷰 생성/삭제
    ```SQL
    --------------------------------------------생성
    CREATE VIEW 뷰_이름[(속성_리스트)] -- 속성_리스트를 생략하면 SELECT 절에 나열된 속성의 이름을 그대로 사용
    AS SELECT 문 -- SELECT문은 생성하려는 뷰의 정의를 표현하며 ORDER BY는 사용 불가
    [WITH CHECK OPTION]; -- 뷰에 삽입이나 수정 연산을 할 때 SELECT 문에서 제시한 뷰의 정의 조건을 위반하면 수행되지 않도록 하는 제약조건을 지정
    --------------------------------------------삭제
    DROP VIEW 뷰_이름;
    ```
    - 뷰 활용
        - INSERT, UPDATE, DELETE  데이터 조작어(DML)가능
            - 뷰에 대한 삽입, 수정, 삭제 연산은 실제로 기본 테이블이 변경됨
            - 뷰에 대한 삽입, 수정, 삭제 연산은 제한적으로 수행됨
            - 변경 불가능한 뷰의 특징
                - 기본 테이블의 기본키를 구성하는 속성이 포함되어 있지 않은 뷰
                - 기본 테이블에 있던 내용이 아닌 집계 함수로 새로 계산된 내용을 포함하는 뷰
                - DISTICNT 키워드를 포함하여 정의한 뷰
                - GROUP BY 절을 포함하여 정의한 뷰
                - 여러 개의 테이블을 조인하여 정의한 뷰는 변경이 불가능한 경우가 많음
        - 장점
            - 질의문을 좀 거 쉽게 작성할 수 있다.
            - 데이터의 보안 유지에 도움이 된다.
            - 데이터를 좀 더 편리하게 관리 할 수 있다.
- 트랜잭션
    - 하나의 작업을 수행하기 위해 필요한 데이터베이스 연산들을 모아놓은것
    - 논리적인 작업의 단위
    - 장애 발생 시 복구 작업이나 병행 제어 작업을 위한 중요한 단위로 사용
    - 데이터베이스의 무결성과 일관성을 보장하기 위해 작업 수행에 필요한 연산들을 하나의 트랜잭션으로 제대로 정의하고 관리해야 함
    - 트랜잭션 특성
        - 원자성
        - 일관성
        - 격리성
        - 지속성
    - 트랜잭션의 4가지 특성을 보장하기 위해 필요한 기능
        - ![17](/img/17.PNG)
    - 트랜잭션 제어어(TCL) : COMMIT, ROLLBACK, SAVEPOINT
    - 트랜잭션의 상태
        - ![18](/img/18.PNG)
- 장애
    - 시스템이 제대로 동작하지 않는 상태
    - 장애의 유형
        - 트랜잭션 장애 : 트랜잭션 수행 중 오류가 발생하여 정상적으로 수행을 계속할 수 없는 상태
        - 시스템 장애 : 하드웨어의 결함으로 정상적으로 수행을 계속할 수 없는 상태
        - 미디어 장애 : 디스크 장치의 결함으로 디스크에 저장된 데이터 베이스의 일부 혹은 전체가 손상된 상태
- 회복
    - 장애가 발생했을 때 데이터베이스를 복구 시키는 것
    - 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적
    - 회복 관리자(recovery manager)가 담당
        - 장애 발생을 탐지하고, 복구 DBMS 안에 있음
    - 회복을 위해 데이터베이스 복사본을 만드는 방법
        - 덤프(DUMP) : 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법
        - 로그(LOG) : 데이터베이스에서 변경연산이 실행될 때마다 데이터를 변경하기 이전값과 변경한 이후의 값을 별도의 파일에 기록하는 방법
- 병행 제어
    - 병행 수행
        - 여러 사용자가 데이터베이스를 동시 공유할 수 있도록 여러 개의 트랜잭션을 동시에 수행하는 것을 의미
    - 병행 제어
        - 병행 수행 시 같은 데이터에 접근하여 연산을 실행해도 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것을 의미
    - 병행 수행 시 발생할 수 있는 문제점
        - 갱신 분실
            - 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것
            - 여러 트랜잭션이 동시에 수행되더라도 갱신 분실 문제가 발생하지 않고 마치 트랜잭션들을 순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 함
        - 모순성
            - 하나의 트랜잭션이 여러 개 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산함으로써 모순된 결과가 발생하는 것
            - 여러 트랜잭션이 동시에 수행되더라도 모순성 문제가 발생하지 않고 마치 트랜잭션들을 순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 함
        - 연쇄 복귀
            - 트랜잭션이 완료되기 전 장애가 발생하여 rollback 연산을 수행하게 되면 장애 발생 전에 이 트랜잭션이 변경한 데이터를 가져가서 변경 연산을 실행한 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것
            - 여러 트랜잭션이 동시에 수행되더라도 연쇄 복쉬 문제가 발생하지 않고 마치 트랜잭션들을 순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 함
    - 로킹(locking)기법
        - 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 끝낼 때 까지는 다른 트랜잭션이 그 데이터에 접근하지 못하도록 상호배제함
        - 병행 수행되는 트랜잭션들이 같은 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산을 이용해 제어
            - lock : 트랜잭션이 데이터에 대한 독점권을 요청하는 연산
            - unlock : 트랜잭션이 데이터에 대한 독점권을 반환하는 연산
- 보안
    - 물리적 환경에 대한 보안
    - 권한 관리를 통한 보안
        - 접근이 허락된 사용자만 권한 내에서 데이터베이스를 사용하도록 보호
        - 계정이 발급된 사용자만 데이터베이스에 접근할 수 있도록 통제하고 각 사용자마다 사용 범위와 수행 가능한 작업 내용을 제한
    - 운영 관리를 통한 보안
        - 접근이 허락된 사용자가 부여된 권한 내에서 데이터베이스를 사용하는 동안 데이터 무결성을 유지하도록 제약조건을 정의하고 위반하지 않도록 통제
    - 권한 관리의 개념
        - DCL을 통한 권한 부여로 접근 제어

## NoSQL